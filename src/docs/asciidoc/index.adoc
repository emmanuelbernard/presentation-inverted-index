= Inverted indices
Emmanuel Bernard
2016-12-20
:hardbreaks:
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../java]
:deckjs_transition: fade
:revealjs_slideNumber: 'c/t'
:navigation:
:menu:
:status:

== What are we here for

Discuss inverted index technology and fundamentals
Understand how search engines work

=== Emmanuel Bernard

++++
<style>
.asciinema-terminal.font-medium {
  font-size: 16px;
}
</style>
++++

Consulting Software Engineer, Red Hat
Platform Architect
Open Source coder:

* Hibernate {ORM,OGM,Search,Validator}
* Debezium, Infinispan, Ceylon, ...

Podcasts: https://lescastcodeurs.com:[Les Cast Codeurs]

https://twitter.com/emmanuelbernard[@emmanuelbernard]
https://emmanuelbernard.com

=== Agenda

TODO: TBD

== Why do we need inverted index

=== Where is it used

[.left]
--
Classical:

* Google, DuckDuckGo
* Mobile phone search
* IDE  auto-completion
--

[.right]
--
Less classical

* geolocation
* suggestion
* faceting
* more like this / classification
* machine learning
--

=== Let's try on RDBMSes

[source,SQL]
----
SELECT * FROM Speakers s WHERE s.bio = 'Open Source'
----

B-Tree index

=== A zoom on B-Trees

TODO: work on B-trees

=== With like

[source,SQL]
----
SELECT * FROM Speakers s WHERE s.bio LIKE 'Open Source%'
----

With like we can have more text after
Still using indices

=== With like in the middle of the column

[source,SQL]
----
SELECT * FROM Speakers s WHERE s.bio LIKE '%Open Source%'
----

Find word anywhere in the text

Table or index scan :(

=== What about uppercase, typos etc

[source,SQL]
----
SELECT * FROM Speakers s WHERE
    s.bio LIKE '%open source%'
    OR s.bio LIKE '%Open Source%'
    OR s.bio LIKE '%opan surce%'
----

Can't anticipate the casing
Can't anticipate all typos

=== What about word ordering and priority

[source,SQL]
----
SELECT * FROM/Speakers s WHERE
    s.bio LIKE '%source open%'
    OR s.bio LIKE '%source%'
    OR s.bio LIKE '%open%'
    ORDER BY best??
----

Words could be in any order
I want the most interesting result first

== Indexing

=== Inverted index to the rescue

Let's not index columns but words
Let's not query values but words

=== At indexing time

[.left.small]
--
doc1: I am your father Luke
doc2: Yes he is your father
doc3: I am gonna make him an offer he can not refuse.
doc4: I love the smell of napalm in the morning.
doc5: One morning I shot an elephant in my pajamas. How he got in my pajamas, I do not know.
--

[.right.small]
--
|===
|word|documents

|am|1,3
|an|3,5
|can|3
|do|5
|elephant|5
|father|1,2
|gonna|3
|got|5
|he|2,3,5
|him|3
|how|5
|i|1,3,4,5
|in|4,5
|is|2
|know|5
|love|4
|luke|1
|make|3
|morning|4,5
|my|5
|not|3,5
|napalm|4
|of|4
|offer|3
|one|5
|pajamas|5
|refuse|3
|shot|5
|smell|4
|the|4
|yes|2
|your|1,2
|===
--

=== At query time

`query: father napalm`
Apply the same word splitting logic
Matching documents: 1, 2 and 4

|===
|word|documents

|father|1,2
|napalm|4
|===



== Indexing details

=== Transforming sentences into words

1. pre-tokenization
2. tokenization
3. filter

Apply the same logic to both document and query content
Each token is the entry in the inverted index pointing to documents

=== Pre-tokenization

Remove unnecessary characters
e.g. remove HTML tags

[source]
----
<p>This is <string>awesome</strong>.</p>
This is awesome.
----

=== Tokenization

Split sentence into words called _tokens_
Split at spaces, dots and other punctuations (with exceptions)

aujourd'hui, A.B.C., and many other rules

One tokenizer per language, but many languages are similar

[#aside]
=== Continuous scripting

Didyouknowwritingtextsinwordsseparatedbyspaceisnotthatold
itstartedinthemiddleage
Itwasnotaproblemaspeoplewerereadingoutloudwrittentext
Infactsplittingwordswasaninventionnecessary
becausemonksshouldremainsilentandlatinwasnolongertheirnativetongue

=== Filtering: where the magic happens

Operate on the stream of tokens
Change, remove or even add tokens

lowercase, stopwords

[source]
--
Sentence: This is AWESOME Peter!
Tokens: |This|is|AWERSOME|Peter|
stopwords: |AWESOME|Peter|
lowercase: |awesome|peter|
--

=== 


== Quering time

== Scoring

== Inverted index physical representation

A Lucene example

=== File structure

[NOTE.speaker]
--
B-Tree, not fast enough
--

=== Log-Structured Merge

=== Uninverted index

== Thank you!

* Slides and code : https://github.com/melix/virtualjug-fast-builds
* Gradle documentation : http://gradle.org/documentation/
* Follow me: http://twitter.com/CedricChampeau[@CedricChampeau]

Learn more at https://gradle.org[www.gradle.org]


