= Inverted indices
Emmanuel Bernard
2016-12-20
:hardbreaks:
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../java]
:deckjs_transition: fade
:revealjs_slideNumber: 'c/t'
:navigation:
:menu:
:status:

== What are we here for

Discuss inverted index technology and fundamentals
Understand how search engines work

=== Emmanuel Bernard

++++
<style>
.asciinema-terminal.font-medium {
  font-size: 16px;
}
</style>
++++

Consulting Software Engineer, Red Hat
Platform Architect
Open Source coder:

* Hibernate {ORM,OGM,Search,Validator}
* Debezium, Infinispan, Ceylon, ...

Podcasts: https://lescastcodeurs.com:[Les Cast Codeurs]

https://twitter.com/emmanuelbernard[@emmanuelbernard]
https://emmanuelbernard.com

=== Agenda

TODO: TBD

== Why do we need inverted index

=== Where is it used

[.left]
--
Classical:

* Google, DuckDuckGo
* Mobile phone search
* IDE  auto-completion
--

[.right]
--
Less classical

* geolocation
* suggestion
* faceting
* more like this / classification
* machine learning
--

=== Let's try on RDBMSes

[source,SQL]
----
SELECT * FROM Speakers s WHERE s.bio = 'Open Source'
----

B-Tree index

=== A zoom on B-Trees

TODO: work on B-trees

=== With like

[source,SQL]
----
SELECT * FROM Speakers s WHERE s.bio LIKE 'Open Source%'
----

With like we can have more text after
Still using indices

=== With like in the middle of the column

[source,SQL]
----
SELECT * FROM Speakers s WHERE s.bio LIKE '%Open Source%'
----

Find word anywhere in the text

Table or index scan :(

=== What about uppercase, typos etc

[source,SQL]
----
SELECT * FROM Speakers s WHERE
    s.bio LIKE '%open source%'
    OR s.bio LIKE '%Open Source%'
    OR s.bio LIKE '%opan surce%'
----

Can't anticipate the casing
Can't anticipate all typos

=== What about word ordering and priority

[source,SQL]
----
SELECT * FROM/Speakers s WHERE
    s.bio LIKE '%source open%'
    OR s.bio LIKE '%source%'
    OR s.bio LIKE '%open%'
    ORDER BY best??
----

Words could be in any order
I want the most interesting result first

== Indexing

=== Inverted index to the rescue

Let's not index columns but words
Let's not query values but words

[%notitle]
[%stretch]
=== Example

[.left]
--
> doc1: I am your father Luke
> doc2: Yes he is your father
> doc3: I am gonna make him an offer he can't refuse.
> doc4: I love the smell of napalm in the morning.
> doc5: One morning I shot an elephant in my pajamas. How he got in my pajamas, I don't know.
--

[.right]
--
|===
|word|documents
|am|1,3
|father|1,2
|he|2
|i|1,3
|is|2
|luke|1
|yes|2
|your|1,2
|===
--


TODO: image of inverted index structure and link to document id


== Indexing details

== Quering time

== Scoring

== Inverted index physical representation

A Lucene example

=== File structure

[NOTE.speaker]
--
B-Tree, not fast enough
--

=== Log-Structured Merge

=== Uninverted index

== Thank you!

* Slides and code : https://github.com/melix/virtualjug-fast-builds
* Gradle documentation : http://gradle.org/documentation/
* Follow me: http://twitter.com/CedricChampeau[@CedricChampeau]

Learn more at https://gradle.org[www.gradle.org]


